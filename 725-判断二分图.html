<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>

        // 着色问题 bfs
        var isBipartite1 = function (graph) {
            const n = graph.length
            // -1 表示未着色
            const colored = new Array(n).fill(-1)
            const map = new Map()
            for (let i = 0; i < n; i++) {
                map.set(i, graph[i])
            }
            // 从 0 开始
            const queue = []
            debugger
            let next, toggle = 0
            // 开始着色 两种颜色 0 / 1
            // colored[0] = toggle
            // toggle = Number(!Boolean(toggle))
            let length, index = 0
            do {
                // 一个连通图的开始，且顶点未被着色
                while (index < n && colored[index] !== -1) {
                    index++
                }
                if (index >= n) return true
                queue.push(index)
                length = queue.length

                while (queue.length) {
                    for (let i = 0; i < length; i++) {
                        next = queue.shift()
                        for (const ele of map.get(next)) {
                            if (colored[ele] === -1) {
                                for (const nei of map.get(ele)) {
                                    if (colored[nei] === toggle) return false
                                }
                                colored[ele] = toggle
                                queue.push(ele)
                            }
                        }
                    }
                    toggle = Number(!Boolean(toggle))
                    length = queue.length
                }
            } while (index < n)

            return true
        };

        // bfs 着色问题
        var isBipartite2 = function (graph) {
            const n = graph.length
            // -1 表示未着色
            const colored = new Array(n).fill(-1)
            let index = 0, toggle = true, length, next
            const queue = []
            // 最外层是连通分量的遍历
            debugger
            for (let i = 0; i < n; i++) {
                if (colored[i] === -1) {
                    // 压入起点
                    queue.push(i)
                    length = queue.length
                    colored[i] = toggle
                    toggle = !toggle
                    while (queue.length) {
                        for (let j = 0; j < length; j++) {
                            next = queue.shift()
                            for (const nei of graph[next]) {
                                for (const ele of graph[nei]) {
                                    if (colored[ele] === toggle) {
                                        return false
                                    }
                                }
                                colored[nei] = toggle
                                queue.push(nei)
                            }
                        }
                        length = queue.length
                        toggle = !toggle
                    }
                }
            }
            return true
        };

        var isBipartite = function (graph) {
            const n = graph.length
            // 初始化，-1表示未着色
            const colored = new Array(n).fill(-1)
            const queue = []
            let next
            // 表示对于不同连通图的遍历
            debugger
            for (let i = 0; i < n; i++) {
                if (colored[i] === -1) {
                    queue.push(i)
                    colored[i] = true
                    while (queue.length) {
                        next = queue.shift()
                        for (const nei of graph[next]) {
                            if (colored[nei] === colored[next]) {
                                return false
                            } else if (colored[nei] === -1) {
                                colored[nei] = !colored[next]
                                queue.push(nei)
                            }
                        }
                    }
                }
            }
            return true
        };

        // isBipartite([[1, 2, 3], [0, 2], [0, 1, 3], [0, 2]])
        // isBipartite([[], [2, 4, 6], [1, 4, 8, 9], [7, 8], [1, 2, 8, 9], [6, 9], [1, 5, 7, 8, 9], [3, 6, 9], [2, 3, 4, 6, 9], [2, 4, 5, 6, 7, 8]])
        // isBipartite([[4], [], [4], [4], [0, 2, 3]])
        isBipartite([[1, 3], [0, 2], [1, 3], [0, 2]])
    </script>
</body>

</html>