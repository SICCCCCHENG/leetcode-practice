<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>

        // 迪杰斯特拉算法
        var networkDelayTime1 = function (times, n, k) {
            const map = new Map()
            const isVisited = new Array(n + 1).fill(0).map(() => ({ final: false, cost: Infinity }))
            let maxCost = 0
            let count = 0, cost
            let candidate
            const queue = [{ node: k, cost: 0 }]
            // initiate the adjcent table
            for (const [src, dest, cost] of times) {
                if (!map.has(dest)) {
                    map.set(dest, [])
                }
                if (!map.has(src)) {
                    map.set(src, [{ dest, cost }])
                } else {
                    map.get(src).push({ dest, cost })
                }
            }
            debugger
            while (queue.length) {
                candidate = queue.shift()
                count++
                maxCost = Math.max(maxCost, candidate.cost)
                isVisited[candidate.node].final = true
                isVisited[candidate.node].cost = candidate.cost
                for (const next of map.get(candidate.node)) {
                    if (!isVisited[next.dest].final) { // 若不是最终确定下来
                        cost = candidate.cost + next.cost
                        if (cost < isVisited[next.dest].cost) {
                            isVisited[next.dest].cost = cost
                            queue.push({ node: next.dest, cost })
                            sort(queue)
                        }
                    }
                }
            }
            return count === n ? maxCost : -1
        };
        const sort = (arr) => {
            arr.sort((a, b) => a.cost - b.cost)
        }

        var networkDelayTime = function (times, n, k) {
            const INF = Number.MAX_SAFE_INTEGER;
            debugger
            const g = new Array(n).fill(INF).map(() => new Array(n).fill(INF));
            for (const t of times) {
                const x = t[0] - 1, y = t[1] - 1;
                g[x][y] = t[2];
            }

            const dist = new Array(n).fill(INF);
            dist[k - 1] = 0;
            const used = new Array(n).fill(false);
            for (let i = 0; i < n; ++i) {
                // 以下的第一个循环是指取到待定的最小的节点的下标
                let x = -1;
                for (let y = 0; y < n; ++y) {
                    if (!used[y] && (x === -1 || dist[y] < dist[x])) {
                        x = y;
                    }
                }
                used[x] = true;
                for (let y = 0; y < n; ++y) {
                    dist[y] = Math.min(dist[y], dist[x] + g[x][y]);
                }
            }

            let ans = Math.max(...dist);
            return ans === INF ? -1 : ans;
        };

        var networkDelayTime3 = function (times, n, k) {
            const map = new Map()
            const visited = new Set()
            let maxCost = 0, pre
            const time = new Array(n + 1).fill(Infinity)
            // 出发点的 cost 为 0
            time[k] = 0
            const priorityQueue = [k]
            // 建立邻接表
            for (const [src, next, cost] of times) {
                if (!map.has(next)) {
                    map.set(next, [])
                }
                if (!map.has(src)) {
                    map.set(src, [{ next, cost }])
                } else {
                    map.get(src).push({ next, cost })
                }
            }
            debugger
            while (priorityQueue.length) {
                pre = priorityQueue.pop()
                if (visited.has(pre)) continue
                visited.add(pre)
                maxCost = Math.max(maxCost, time[pre])
                for (const { next, cost } of map.get(pre)) {
                    if (!visited.has(next)) {
                        const newCost = time[pre] + cost
                        if (time[next] > newCost) {
                            time[next] = time[pre] + cost
                            priorityQueue.push(next)
                        }
                    }
                }
                priorityQueue.sort((a, b) => time[b] - time[a])
            }
            return visited.size === n ? maxCost : -1
        };

        var networkDelayTime4 = function (times, n, k) {
            // 建立邻接矩阵
            const table = new Array(n + 1).fill(0).map(() => new Array(n + 1).fill(undefined))
            const length = times.length
            for (const [src, dest, cost] of times) {
                table[src][dest] = cost
            }
            table[k][k] = 0
            const visited = new Set()
            const cost = new Array(n + 1).fill(Infinity)
            cost[k] = 0
            const priorityQueue = [k]
            let next, maxCost = 0
            while (priorityQueue.length) {
                next = priorityQueue.pop()
                if (visited.has(next)) continue
                visited.add(next)
                maxCost = Math.max(maxCost, cost[next])
                for (let i = 1; i <= n; i++) {
                    if (!visited.has(i) && table[next][i] !== undefined) {
                        if (cost[i] > (cost[next] + table[next][i])) {
                            cost[i] = cost[next] + table[next][i]
                            priorityQueue.push(i)
                            priorityQueue.sort((a, b) => cost[b] - cost[a])
                        }
                    }
                }
            }
            return visited.size === n ? maxCost : -1
        };

        // networkDelayTime([[1, 2, 1], [2, 3, 2], [1, 3, 4]], 3, 1)
        networkDelayTime([[2, 1, 1], [2, 3, 1], [3, 4, 1]], 4, 2)
        // networkDelayTime([[1, 2, 1]], 2, 2)

    </script>
</body>

</html>